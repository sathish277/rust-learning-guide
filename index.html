<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Learn Rust in 15 Days: Interactive Guide to Mastering Rust Programming
    </title>
    <meta
      name="description"
      content="Master Rust programming with this interactive 15-day learning guide. Covers Rust basics, ownership, borrowing, structs, enums, error handling, modules, traits, generics, lifetimes, smart pointers, concurrency, and testing. Perfect for beginners!"
    />
    <!-- Chosen Palette: Serene Dev (Warm neutrals like amber/gray, with teal/blue accents) -->
    <!-- Application Structure Plan: A two-panel SPA. A persistent left sidebar for non-linear navigation through the 15 days, with progress tracking checkboxes. The right panel displays content for the selected day, organized into a tabbed interface ('Why', 'What', 'When', 'How') to break down complex topics into digestible chunks. This structure improves on the original linear report by providing random access, reducing cognitive load, and adding interactive feedback (progress tracking), which is superior for self-paced learning. -->
    <!-- Visualization & Content Choices:
    - Report Info: 15-day linear learning plan. Goal: Provide overview & track progress. Viz/Presentation: HTML/CSS progress bar at the top and checkboxes in the sidebar. Interaction: Checkboxes update the progress bar. Justification: Visual feedback encourages completion. Library/Method: HTML/CSS/JS.
    - Report Info: Daily topics broken into Why/What/When/How. Goal: Organize and reduce cognitive load. Viz/Presentation: Tabbed interface. Interaction: Clicking tabs reveals content. Justification: Allows users to focus on one aspect at a time. Library/Method: HTML/CSS/JS.
    - Report Info: Code snippets. Goal: Allow easy use and experimentation. Viz/Presentation: Styled code blocks (`<pre><code>`). Interaction: 'Copy to Clipboard' button for each snippet. Justification: Essential utility for a programming tutorial. Library/Method: JS `document.execCommand('copy')`.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #f8fafc; /* gray-50 */
      }
      .sidebar-scrollbar::-webkit-scrollbar {
        width: 5px;
      }
      .sidebar-scrollbar::-webkit-scrollbar-track {
        background: transparent;
      }
      .sidebar-scrollbar::-webkit-scrollbar-thumb {
        background-color: #94a3b8; /* gray-400 */
        border-radius: 20px;
        border: 3px solid transparent;
      }
      .content-scrollbar::-webkit-scrollbar {
        width: 8px;
      }
      .content-scrollbar::-webkit-scrollbar-track {
        background: #e2e8f0; /* gray-200 */
      }
      .content-scrollbar::-webkit-scrollbar-thumb {
        background-color: #64748b; /* gray-500 */
        border-radius: 20px;
      }
      .code-block {
        position: relative;
      }
      .copy-button {
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
        background-color: #475569; /* slate-600 */
        color: #f1f5f9; /* slate-100 */
        padding: 0.25rem 0.5rem;
        border-radius: 0.375rem;
        font-size: 0.75rem;
        cursor: pointer;
        opacity: 0.5;
        transition: opacity 0.2s;
      }
      .code-block:hover .copy-button {
        opacity: 1;
      }
      .sidebar-toggle {
        display: none;
      }
      @media (max-width: 768px) {
        .sidebar-toggle {
          display: block;
        }
        .sidebar {
          transform: translateX(-100%);
          transition: transform 0.3s ease-in-out;
          z-index: 40;
        }
        .sidebar.open {
          transform: translateX(0);
        }
      }
    </style>
  </head>
  <body class="text-slate-800">
    <div id="app" class="h-screen w-screen flex flex-col">
      <!-- Header -->
      <header
        class="bg-white border-b border-slate-200 p-4 shadow-sm w-full flex items-center justify-between z-20"
      >
        <div class="flex items-center gap-4">
          <button
            id="sidebar-toggle"
            class="sidebar-toggle md:hidden p-2 rounded-md hover:bg-slate-100"
          >
            <svg
              class="w-6 h-6"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 6h16M4 12h16m-7 6h7"
              ></path>
            </svg>
          </button>
          <h1 class="text-xl font-bold text-teal-700">
            Interactive Rust Learning Guide
          </h1>
        </div>
        <div class="w-1/3 min-w-[200px]">
          <div class="flex items-center gap-2 text-sm">
            <span id="progress-text" class="text-slate-600">Progress: 0%</span>
            <div class="w-full bg-slate-200 rounded-full h-2.5">
              <div
                id="progress-bar"
                class="bg-teal-600 h-2.5 rounded-full"
                style="width: 0%"
              ></div>
            </div>
          </div>
        </div>
      </header>

      <div class="flex flex-grow overflow-hidden">
        <!-- Sidebar -->
        <nav
          id="sidebar"
          class="sidebar absolute md:relative bg-white border-r border-slate-200 w-64 md:w-72 lg:w-80 flex-shrink-0 h-full overflow-y-auto sidebar-scrollbar"
        >
          <div class="p-4">
            <h2 class="text-lg font-semibold mb-4 text-slate-700">
              15-Day Plan
            </h2>
            <ul id="day-list" class="space-y-1">
              <!-- Days will be dynamically inserted here -->
            </ul>
          </div>
        </nav>

        <!-- Main Content -->
        <main
          id="main-content"
          class="flex-grow bg-slate-50 p-4 sm:p-6 lg:p-8 overflow-y-auto content-scrollbar"
        >
          <div class="max-w-4xl mx-auto">
            <div
              id="content-container"
              class="bg-white p-6 rounded-xl shadow-lg"
            >
              <h2
                id="day-title"
                class="text-3xl font-bold mb-2 text-teal-800"
              ></h2>
              <p id="day-topic" class="text-lg text-slate-500 mb-6"></p>

              <!-- Tabs -->
              <div class="border-b border-slate-200 mb-6">
                <nav id="tabs" class="-mb-px flex space-x-6" aria-label="Tabs">
                  <!-- Tab links will be dynamically inserted here -->
                </nav>
              </div>

              <!-- Tab Content -->
              <div id="tab-content">
                <!-- Content will be dynamically inserted here -->
              </div>

              <!-- Deeper Dive -->
              <div id="deeper-dive-container" class="mt-8">
                <!-- Deeper dive content here -->
              </div>
            </div>
          </div>
        </main>
      </div>
    </div>
    <div
      id="copied-toast"
      class="fixed bottom-5 right-5 bg-slate-800 text-white py-2 px-4 rounded-lg shadow-xl text-sm transition-opacity duration-300 opacity-0"
    >
      Copied to clipboard!
    </div>

    <script>
      const rustGuideData = [
        {
          day: 1,
          title: 'Setup, "Hello, World!", and Cargo',
          why: `This first day is crucial for setting up your development environment. Without the right tools, you can't write or run any Rust code. We'll install the Rust toolchain, write the classic "Hello, World!" program to confirm everything works, and introduce Cargo, Rust's powerful build system and package manager that will make your life much easier.`,
          what: [
            {
              term: "Rust Toolchain",
              def: "Includes \`rustup\` (the installer), \`rustc\` (the compiler), and \`cargo\` (the build tool/package manager).",
            },
            {
              term: '"Hello, World!"',
              def: "A simple program to verify your setup. It introduces \`fn main()\` (the program entry point) and \`println!\` (a macro for printing text).",
            },
            {
              term: "Cargo",
              def: "Rust's all-in-one tool for creating projects (\`cargo new\`), building them (\`cargo build\`), running them (\`cargo run\`), and checking for errors (\`cargo check\`).",
            },
          ],
          when: [
            {
              scenario: "Every New Project",
              action:
                "Use \`cargo new\` to create a standardized project structure.",
            },
            {
              scenario: "Development Cycle",
              action:
                "Use \`cargo run\` to compile and execute your code, and \`cargo check\` for faster error checking without building an executable.",
            },
          ],
          how: [
            {
              title: "Install Rust",
              code: `curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh`,
            },
            {
              title: 'Create and Run "Hello, World!"',
              code: `// In your terminal:
// cargo new hello_rust
// cd hello_rust

// This goes in src/main.rs
fn main() {
    println!("Hello, Rustacean!");
}

// In your terminal:
// cargo run`,
            },
          ],
          deeperDive: {
            title: "Why the Tooling is a Big Deal",
            content: `Rust's integrated toolchain is a major advantage. In many systems languages, setting up a compiler, build system, and package manager is a complex, fragmented process. Rust provides a unified, consistent experience with Cargo, letting you focus on learning the language, not fighting with tools. The compiler's helpful, detailed error messages are also a key feature, acting like a tutor that guides you toward correct code.`,
          },
        },
        {
          day: 2,
          title: "Variables, Data Types, and Operations",
          why: `Variables store data, and data types tell Rust what kind of data it is. This is fundamental to any program. Rust's approach is unique because variables are immutable (unchangeable) by default, a key part of its safety promise. You have to be explicit with the \`mut\` keyword if you want a variable to be mutable.`,
          what: [
            {
              term: "Immutability",
              def: "Variables declared with \`let\` cannot be changed. Use \`let mut\` to make them mutable.",
            },
            {
              term: "Scalar Types",
              def: "Represent a single value: Integers (\`i32\`, \`u64\`), Floating-point numbers (\`f64\`), Booleans (\`true\`/\`false\`), and Characters (\`'a'\`).",
            },
            {
              term: "Compound Types",
              def: "Group multiple values: Tuples (fixed size, varied types) and Arrays (fixed size, same type).",
            },
            {
              term: "Shadowing",
              def: "Declaring a new variable with the same name as a previous one. This is useful for transformations, like converting a string to a number.",
            },
          ],
          when: [
            {
              scenario: "Storing Data",
              action:
                "Always default to immutable \`let\`. Only use \`let mut\` when you know the value needs to change.",
            },
            {
              scenario: "Fixed-Size Lists",
              action:
                "Use arrays when you know the exact number of elements at compile time. For dynamic lists, you'll use a \`Vec\` (covered later).",
            },
          ],
          how: [
            {
              title: "Immutability and Mutability",
              code: `fn main() {
    let x = 5; // immutable
    // x = 6; // This would be a compile error!

    let mut y = 10; // mutable
    y = 11; // This is okay.
    println!("y is {}", y);
}`,
            },
            {
              title: "Data Types Example",
              code: `fn main() {
    let is_active: bool = true;
    let grade: char = 'A';
    
    // tuple with different types
    let person: (String, i32) = ("Alice".to_string(), 30);
    println!("{} is {} years old", person.0, person.1);

    // array with same type
    let numbers: [i32; 5] = [1, 2, 3, 4, 5];
    println!("First number is {}", numbers[0]);
}`,
            },
          ],
          deeperDive: {
            title: "Safety by Default",
            content: `Default immutability prevents a huge class of bugs where data is changed unexpectedly. It makes your code easier to reason about. Similarly, Rust's array access is bounds-checked at runtime. Trying to access an index that doesn't exist will cause the program to \`panic\` (stop safely), preventing memory corruption that can occur in other languages.`,
          },
        },
        {
          day: 3,
          title: "Functions and Control Flow",
          why: "Functions organize code into reusable blocks, and control flow directs the path your program takes. \`if\`/\`else\` lets you make decisions, while loops (\`for\`, \`while\`, \`loop\`) let you repeat actions. Understanding that most control flow constructs in Rust are *expressions* (they return a value) is key to writing concise, idiomatic code.",
          what: [
            {
              term: "Functions",
              def: "Defined with \`fn\`. They require type annotations for all parameters and for the return value (\`-> Type\`).",
            },
            {
              term: "Expressions vs. Statements",
              def: "Expressions evaluate to a value (e.g., \`5 + 6\`). Statements perform an action and don't return a value (e.g., \`let x = 5;\`). A semicolon turns an expression into a statement.",
            },
            {
              term: "Control Flow",
              def: "\`if\`/\`else\` for conditions. \`loop\` for infinite loops. \`while\` for conditional loops. \`for\` for iterating over collections.",
            },
            {
              term: "\`match\`",
              def: "A powerful control flow construct that compares a value against a series of patterns and executes code based on which pattern matches. It must be exhaustive.",
            },
          ],
          when: [
            {
              scenario: "Making Decisions",
              action:
                "Use \`if\`/\`else\` for simple boolean logic. Use \`match\` when you have multiple possible states for a value, especially with enums.",
            },
            {
              scenario: "Iteration",
              action:
                "Prefer \`for\` loops for iterating over collections like arrays. They are safer and more concise than manual indexing with a \`while\` loop.",
            },
          ],
          how: [
            {
              title: "Function Definition",
              code: `fn add(a: i32, b: i32) -> i32 {
    a + b // No semicolon means this is an expression, and its value is returned
}

fn main() {
    let sum = add(5, 7);
    println!("The sum is {}", sum);
}`,
            },
            {
              title: "`if` as an Expression",
              code: `fn main() {
    let number = 6;
    let result = if number % 2 == 0 {
        "even"
    } else {
        "odd"
    };
    println!("The number is {}", result);
}`,
            },
            {
              title: "`for` Loop",
              code: `fn main() {
    let a = [10, 20, 30, 40, 50];
    for element in a {
        println!("the value is: {}", element);
    }
}`,
            },
          ],
          deeperDive: {
            title: "Expression-Oriented Power",
            content:
              "Because \`if\` and \`match\` are expressions, you can use them directly in \`let\` statements, eliminating temporary variables and making code more direct. The exhaustiveness of \`match\` is a major safety feature. The compiler forces you to handle every possible case, preventing bugs from forgotten states that might cause crashes in other languages.",
          },
        },
        {
          day: 4,
          title: "Ownership - Rust's Core Concept (Part 1)",
          why: "Ownership is Rust's most unique feature and its solution to memory safety without a garbage collector. It's a set of rules the compiler checks at compile time to prevent common memory errors like 'double frees' or using memory after it's been freed. Understanding this is non-negotiable for writing Rust.",
          what: [
            {
              term: "Ownership Rules",
              def: "1. Each value has one owner. 2. There can only be one owner at a time. 3. When the owner goes out of scope, the value is dropped (memory is freed).",
            },
            {
              term: "Stack vs. Heap",
              def: "Stack is for fixed-size, known data (fast). Heap is for dynamic, growable data (slower). Ownership primarily manages heap data.",
            },
            {
              term: "Move Semantics",
              def: "For heap-allocated types like \`String\`, assignment transfers ownership. \`let s2 = s1;\` moves ownership to \`s2\`, and \`s1\` becomes invalid.",
            },
            {
              term: "\`Copy\` Trait",
              def: "For simple, stack-only types (like \`i32\`), assignment makes a copy, and the original variable remains valid.",
            },
            {
              term: "\`clone()\`",
              def: "To explicitly make a deep copy of heap data (like a \`String\`), you must call the \`.clone()\` method.",
            },
          ],
          when: [
            {
              scenario: "Passing data",
              action:
                "When you pass a heap-allocated value (like a \`String\`) to a function, ownership is moved into the function by default.",
            },
            {
              scenario: "Duplicating data",
              action:
                "If you need two independent copies of a \`String\`, you must explicitly \`clone()\` it. This makes expensive operations visible in the code.",
            },
          ],
          how: [
            {
              title: "Move Semantics (String)",
              code: `fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // Ownership is moved from s1 to s2.

    // println!("s1 = {}", s1); // This fails to compile! s1 is no longer valid.
    println!("s2 = {}", s2); // This is fine.
}`,
            },
            {
              title: "Copy Semantics (i32)",
              code: `fn main() {
    let x = 5;
    let y = x; // A copy is made.

    println!("x = {}, y = {}", x, y); // Both are still valid.
}`,
            },
          ],
          deeperDive: {
            title: "Performance and Safety Combined",
            content:
              "The move semantic is fast because it only copies the pointer, length, and capacity data on the stack, not the actual data on the heap. By making expensive deep copies explicit with \`.clone()\`, Rust gives developers control over performance. The ownership system guarantees at compile time that memory will be cleaned up exactly once when the owner goes out of scope, eliminating memory leaks and other common bugs without the runtime cost of a garbage collector.",
          },
        },
        {
          day: 5,
          title: "Borrowing and References (Part 2 of Ownership)",
          why: "Moving ownership all the time would be very restrictive. Borrowing allows you to 'lend' access to data without giving up ownership. This is done via references. The borrow checker enforces rules to ensure this is done safely, preventing data races and dangling pointers.",
          what: [
            {
              term: "Reference (\`&\`)",
              def: "A way to refer to a value without taking ownership of it. The value is 'borrowed'.",
            },
            {
              term: "Immutable Reference (\`&T\`)",
              def: "Allows read-only access. You can have many immutable references to the same data at once.",
            },
            {
              term: "Mutable Reference (\`&mut T\`)",
              def: "Allows read-write access. You can only have ONE mutable reference to a particular piece of data in a particular scope.",
            },
            {
              term: "The Borrowing Rules",
              def: "You can have either one mutable reference OR any number of immutable references, but not both at the same time.",
            },
          ],
          when: [
            {
              scenario: "Reading data in a function",
              action:
                "Pass an immutable reference (\`&String\`) to a function to let it read the string's value without taking ownership.",
            },
            {
              scenario: "Modifying data in place",
              action:
                "Pass a mutable reference (\`&mut String\`) to a function to allow it to modify the string.",
            },
          ],
          how: [
            {
              title: "Immutable Borrow",
              code: `fn calculate_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1); // We pass a reference to s1.
    println!("The length of '{}' is {}.", s1, len); // s1 is still valid here.
}`,
            },
            {
              title: "Mutable Borrow (Rule Enforcement)",
              code: `fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    // let r2 = &mut s; // COMPILE ERROR! Cannot borrow as mutable more than once.
    
    println!("{}", r1);
}`,
            },
          ],
          deeperDive: {
            title: 'The Foundation of "Fearless Concurrency"',
            content:
              "The borrowing rules are what prevent data races at compile time. A data race occurs when two or more pointers access the same data at the same time, at least one is writing, and there's no synchronization. Rust's rule of 'one mutable OR many immutable' makes this entire class of bug impossible. The compiler enforces this for single-threaded code, and this same guarantee extends to multi-threaded code, making concurrency much safer.",
          },
        },
        {
          day: 6,
          title: "Slices - Safe Views into Collections",
          why: "Slices give you a way to reference a contiguous sequence of elements in a collection (like a String or an array) rather than the whole collection. This is a form of borrowing, so it doesn't take ownership and is very efficient because it doesn't copy data.",
          what: [
            {
              term: "Slice",
              def: "A reference to a part of a collection. It stores a pointer to the start of the slice and its length.",
            },
            {
              term: "String Slice (\`&str\`)",
              def: 'A reference to part of a \`String\`. String literals (\`"hello"\`) are also of type \`&str\`.',
            },
            {
              term: "Array Slice (\`&\`])",
              def: "A reference to part of an array.",
            },
            {
              term: "Borrowing Rules",
              def: "Slices follow the same borrowing rules. If you have an immutable slice of a collection, you cannot get a mutable reference to the collection until the slice is no longer used.",
            },
          ],
          when: [
            {
              scenario: "Function Parameters",
              action:
                "It's often more idiomatic to accept \`&str\` in a function than \`&String\`. This makes the function more flexible, as it can accept both \`String\`s and string literals.",
            },
            {
              scenario: "Parsing Text",
              action:
                "Slices are perfect for writing functions that find and return parts of a string, like the first word, without needing to create new strings.",
            },
          ],
          how: [
            {
              title: "Creating Slices",
              code: `fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];

    println!("{} {}", hello, world);
}`,
            },
            {
              title: "A `first_word` Function",
              code: `fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}

fn main() {
    let my_string = String::from("hello rust");
    let word = first_word(&my_string);
    println!("The first word is: {}", word);
}`,
            },
          ],
          deeperDive: {
            title: "Safety and Performance Hand-in-Hand",
            content:
              "The borrow checker ensures that slices cannot become dangling pointers. If you have a slice, the compiler guarantees the underlying data will not be dropped or modified in an incompatible way until the slice goes out of scope. This gives you the performance of pointer-based access with the complete memory safety of Rust, a prime example of a \`zero-cost abstraction\`.",
          },
        },
        {
          day: 7,
          title: "Structs - Custom Data Types",
          why: "Structs let you create your own custom data types by grouping related values. This is essential for modeling real-world concepts, organizing your code, and making it more readable and type-safe. They are the primary way to build complex data structures in Rust.",
          what: [
            {
              term: "Struct",
              def: "A custom data type with named fields. Defined with the \`struct\` keyword.",
            },
            {
              term: "Instance",
              def: "A concrete value created from a struct definition.",
            },
            {
              term: "Methods (\`impl\`)",
              def: "Functions associated with a struct. They are defined in an \`impl\` block and their first parameter is usually \`&self\` (an immutable borrow of the instance) or \`&mut self\` (a mutable borrow).",
            },
            {
              term: "Associated Functions",
              def: "Functions within an \`impl\` block that don't take \`self\`. They are often used as constructors, like \`StructName::new()\`, and are called with \`::\` syntax.",
            },
          ],
          when: [
            {
              scenario: "Modeling Data",
              action:
                "Use a struct to represent an entity with multiple attributes, like a \`User\` with a \`username\` and \`email\`.",
            },
            {
              scenario: "Adding Behavior",
              action:
                "Use an \`impl\` block to define methods that operate on the struct's data, like a \`Rectangle\` struct with an \`area()\` method.",
            },
          ],
          how: [
            {
              title: "Defining and Using a Struct",
              code: `#[derive(Debug)]
struct User {
    username: String,
    email: String,
    active: bool,
}

fn main() {
    let mut user1 = User {
        email: String::from("user@example.com"),
        username: String::from("someuser123"),
        active: true,
    };

    user1.email = String::from("anotheremail@example.com");
    println!("{:#?}", user1);
}`,
            },
            {
              title: "Struct with Methods",
              code: `#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // This is a method
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    // This is an associated function (constructor)
    fn square(size: u32) -> Self {
        Self { width: size, height: size }
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("The area is {}", rect1.area());
    
    let sq = Rectangle::square(25);
    println!("Square: {:#?}", sq);
}`,
            },
          ],
          deeperDive: {
            title: "Composition Over Inheritance",
            content:
              "Rust doesn't have inheritance in the classical sense. Instead, it favors composition (building types out of other types) and shared behavior via traits (Day 11). This leads to more flexible and less rigid code designs. \`impl\` blocks allow you to separate a struct's data definition from its behavior, which helps in organizing large codebases.",
          },
        },
        {
          day: 8,
          title: "Enums and Pattern Matching",
          why: "Enums (enumerations) allow you to define a type that can be one of several possible variants. They are incredibly powerful in Rust because each variant can hold different types and amounts of data. Combined with the \`match\` statement, enums let you handle different states or types of data in a safe and exhaustive way.",
          what: [
            {
              term: "Enum",
              def: "A type that can have a few definite values, called variants. E.g., \`enum IpAddr { V4, V6 }\`.",
            },
            {
              term: "Variants with Data",
              def: "Each enum variant can store data. E.g., \`enum Message { Quit, Write(String), Move { x: i32, y: i32 } }\`.",
            },
            {
              term: "\`Option<T>\`",
              def: "A very common standard library enum for handling values that might be absent. It has two variants: \`Some(T)\` (a value is present) and \`None\` (no value is present). This is Rust's safe alternative to \`null\`.",
            },
            {
              term: "\`match\`",
              def: "A control flow construct that shines with enums. It forces you to handle every possible variant, which prevents bugs.",
            },
            {
              term: "\`if let\`",
              def: "A less verbose way to handle a single enum variant and ignore the rest.",
            },
          ],
          when: [
            {
              scenario: "Handling Nullability",
              action:
                "Any time a value could be missing, use \`Option<T>\` instead of trying to represent null. This forces you to handle the \`None\` case.",
            },
            {
              scenario: "State Machines",
              action:
                "Enums are perfect for defining the states of a system and using \`match\` to handle transitions between them.",
            },
          ],
          how: [
            {
              title: "Enum with Data and `match`",
              code: `enum Message {
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn process_message(msg: Message) {
    match msg {
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("Change color to: R={}, G={}, B={}", r, g, b)
        },
    }
}

fn main() {
    process_message(Message::Write("Hello".to_string()));
}`,
            },
            {
              title: "Using `Option<T>`",
              code: `fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
    println!("Six: {:?}, None: {:?}", six, none);
}`,
            },
          ],
          deeperDive: {
            title: 'Eliminating the "Billion-Dollar Mistake"',
            content:
              "The inventor of \`null\` called it his \"billion-dollar mistake\" because of the countless errors, vulnerabilities, and system crashes it has caused. Rust solves this with \`Option<T>\`. Because \`Option<T>\` and \`T\` are different types, the compiler won't let you use an \`Option<T>\` as if it's definitely a valid value. You must convert it, which means you have to handle the \`None\` case. This eliminates null pointer errors at compile time.",
          },
        },
        {
          day: 9,
          title: "Error Handling - Robustness in Rust",
          why: "Robust software must handle errors gracefully. Rust enforces this by distinguishing between recoverable errors (e.g., file not found) and unrecoverable errors (bugs, e.g., index out of bounds). This distinction forces you to think about and handle potential failures, leading to more reliable programs.",
          what: [
            {
              term: "Unrecoverable Errors (\`panic!\`)",
              def: "For programming errors that should not happen. \`panic!\` stops the program immediately. \`unwrap()\` and \`expect()\` on \`Option\`/\`Result\` will panic on \`None\`/\`Err\`.",
            },
            {
              term: "Recoverable Errors (\`Result<T, E>\`)",
              def: "The standard enum for operations that can fail. It has two variants: \`Ok(T)\` for success (containing a value) and \`Err(E)\` for failure (containing an error).",
            },
            {
              term: "Handling \`Result\`",
              def: "Use \`match\` for explicit handling of \`Ok\` and \`Err\`. Use \`unwrap()\` or \`expect()\` only when you are certain failure is impossible (e.g., in tests).",
            },
            {
              term: "Error Propagation (\`?\` operator)",
              def: "A clean way to pass an error up to the calling function. If a \`Result\` is \`Err\`, the \`?\` operator will immediately return the \`Err\` from the current function.",
            },
          ],
          when: [
            {
              scenario: "I/O Operations",
              action:
                "File or network operations can often fail. They should always return a \`Result\`.",
            },
            {
              scenario: "Parsing",
              action:
                "Parsing a string into a number might fail if the string is malformed. This is a perfect use case for \`Result\`.",
            },
            {
              scenario: "Writing clean functions",
              action:
                "Use the \`?\` operator to avoid deeply nested \`match\` statements and keep your error-handling logic clean.",
            },
          ],
          how: [
            {
              title: "Handling `Result` with `match`",
              code: `use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}`,
            },
            {
              title: "Propagating Errors with `?`",
              code: `use std::io;
use std::fs::File;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();
    // The \`?\` returns the error from the function if \`File::open\` fails.
    File::open("hello.txt")?.read_to_string(&mut s)?;
    Ok(s)
}

fn main() {
    match read_username_from_file() {
        Ok(name) => println!("Username: {}", name),
        Err(e) => println!("Error: {}", e),
    }
}`,
            },
          ],
          deeperDive: {
            title: "Errors as First-Class Citizens",
            content:
              "In Rust, errors are not exceptions; they are ordinary values. The \`Result\` enum makes potential failure an explicit part of a function's type signature. This means the compiler can ensure you've handled potential errors. If a function returns \`Result<String, io::Error>\`, you *must* handle the \`io::Error\` case. You cannot forget. This makes Rust code exceptionally robust.",
          },
        },
        {
          day: 10,
          title: "Modules, Crates, and the Rust Ecosystem",
          why: "As projects grow, you need to organize your code. Rust provides a powerful module system to split code into logical units, controlling privacy and scope. \`crates\` are units of compilation (libraries or binaries), and \`packages\` are bundles of crates managed by Cargo. Understanding this is key to building large applications and using third-party code.",
          what: [
            {
              term: "Package",
              def: "A Cargo feature that lets you build, test, and share crates. Contains a \`Cargo.toml\` file.",
            },
            {
              term: "Crate",
              def: "A library or binary. The smallest amount of code the Rust compiler considers at a time.",
            },
            {
              term: "Module (\`mod\`)",
              def: "A way to group related code and control privacy within a crate. Items are private by default.",
            },
            {
              term: "Visibility (\`pub\`)",
              def: "The \`pub\` keyword makes an item (module, function, struct) public and accessible from outside its module.",
            },
            {
              term: "\`use\` keyword",
              def: "Brings a path into scope so you can use a shorter name. E.g., \`use std::collections::HashMap;\`",
            },
            {
              term: "\`crates.io\`",
              def: "The Rust community's official crate registry, where you can find and download thousands of libraries.",
            },
          ],
          when: [
            {
              scenario: "Large Projects",
              action:
                "Break your code into multiple files and use \`mod\` declarations to build a module tree.",
            },
            {
              scenario: "Creating a Library",
              action:
                "Place your public API in \`src/lib.rs\` and use \`pub\` to expose only the necessary parts.",
            },
            {
              scenario: "Using External Code",
              action:
                "Add a dependency to your \`Cargo.toml\` file, and Cargo will download and build it for you.",
            },
          ],
          how: [
            {
              title: "Defining a Module",
              code: `// in src/lib.rs
pub mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();
    // Relative path
    front_of_house::hosting::add_to_waitlist();
}`,
            },
            {
              title: "Using `use`",
              code: `use crate::front_of_house::hosting;
// Or even: use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    // add_to_waitlist(); // If the full function was brought into scope
}`,
            },
          ],
          deeperDive: {
            title: "APIs by Design",
            content:
              'The "private by default" rule is a powerful feature for API design. It forces you to be intentional about what you expose to users of your library. This makes refactoring internal code much safer, as you know you\'t break external code that depends on your library, as long as you maintain the public API. Cargo and crates.io make sharing and using code incredibly simple and reliable.',
          },
        },
        {
          day: 11,
          title: "Traits - Shared Behavior",
          why: "Traits are how Rust achieves polymorphism. They are similar to interfaces in other languages, allowing you to define a set of methods that a type must implement to share a certain behavior. This allows you to write generic, flexible code that can operate on any type that has the required behavior.",
          what: [
            {
              term: "Trait",
              def: "A definition of shared behavior, consisting of method signatures. E.g., a \`Summary\` trait could have a \`summarize()\` method.",
            },
            {
              term: "\`impl Trait for Type\`",
              def: "The syntax used to implement a trait for a specific type, providing the concrete code for the trait's methods.",
            },
            {
              term: "Trait Bounds",
              def: "Using traits to constrain generic types. \`fn notify<T: Summary>(item: &T)\` means this function works for any type \`T\` that implements the \`Summary\` trait.",
            },
            {
              term: "\`impl Trait\` syntax",
              def: "A cleaner syntax for trait bounds in function arguments (\`fn notify(item: &impl Summary)\`) and return types.",
            },
          ],
          when: [
            {
              scenario: "Generalizing Functions",
              action:
                "Write a function that accepts any type implementing a specific trait (e.g., \`Display\` for printing) to make it more reusable.",
            },
            {
              scenario: "Defining an Interface",
              action:
                "When creating a library, define traits to allow users to make their own types compatible with your library.",
            },
          ],
          how: [
            {
              title: "Defining and Implementing a Trait",
              code: `pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct NewsArticle {
    pub headline: String,
    pub author: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {}", self.headline, self.author)
    }
}`,
            },
            {
              title: "Using Trait Bounds",
              code: `pub trait Summary { fn summarize(&self) -> String; }
// ... (struct and impl from above)

// This function accepts any type that implements the Summary trait.
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

fn main() {
    let article = NewsArticle {
        headline: String::from("Rust is awesome!"),
        author: String::from("A. Rustacean"),
    };
    notify(&article);
}`,
            },
          ],
          deeperDive: {
            title: "Static vs. Dynamic Dispatch",
            content:
              "When you use trait bounds with generics, Rust performs 'static dispatch'. At compile time, it creates a specific version of the function for each concrete type you use it with. This is called monomorphization and means there is zero runtime cost for the abstraction. This is a key reason Rust can be both highly abstract and extremely fast.",
          },
        },
        {
          day: 12,
          title: "Generics - Flexible and Reusable Code",
          why: "Generics allow you to write code that is not specific to a single data type. This is fundamental for avoiding code duplication. You can write a function, struct, or enum once and have it work for many different concrete types, all while maintaining full compile-time type safety.",
          what: [
            {
              term: "Generic Functions",
              def: "Functions that take generic type parameters, like \`fn func<T>(arg: T)\`.",
            },
            {
              term: "Generic Structs",
              def: "Structs that can hold fields of any type, like \`struct Point<T> { x: T, y: T }\`.",
            },
            {
              term: "Trait Bounds",
              def: "Used with generics to specify what capabilities a generic type must have. For example, to compare two values of type \`T\`, \`T\` must implement the \`PartialOrd\` trait.",
            },
            {
              term: "Monomorphization",
              def: "The process Rust uses to turn generic code into specific code at compile time. This makes generics in Rust have no runtime performance cost.",
            },
          ],
          when: [
            {
              scenario: "Data Structures",
              action:
                "Create a generic \`Stack<T>\` or \`Point<T>\` that can hold any type of data.",
            },
            {
              scenario: "Algorithms",
              action:
                "Write a \`largest<T>(list: &)\` function that can find the largest item in a slice of any comparable type.",
            },
          ],
          how: [
            {
              title: "Generic Struct and Method",
              code: `struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!("integer.x = {}", integer.x());
}`,
            },
            {
              title: "Generic Function with Trait Bounds",
              code: `// This function works for any type T that implements the
// PartialOrd (for comparison) and Copy traits.
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];
    println!("Largest number: {}", largest(&numbers));
}`,
            },
          ],
          deeperDive: {
            title: "Zero-Cost Abstractions at Work",
            content:
              "Monomorphization is a key example of Rust's \`zero-cost abstraction\` philosophy. You get to write clean, abstract, generic code, but the compiler turns it into highly efficient, specialized code that's just as fast as if you had written it by hand for each specific type. The trade-off is potentially larger binary sizes and longer compile times, but for performance-critical systems, runtime speed is what matters most.",
          },
        },
        {
          day: 13,
          title: "Lifetimes - Advanced Reference Validation",
          why: "Lifetimes are the final piece of the ownership puzzle. They are how the borrow checker ensures that references are always valid. While the compiler can infer them in most simple cases (thanks to 'lifetime elision'), you sometimes need to write them out explicitly to help the compiler. This is most common in functions that return references or structs that hold references.",
          what: [
            {
              term: "Lifetime",
              def: "A scope for which a reference is valid. Its main purpose is to prevent dangling references.",
            },
            {
              term: "Lifetime Annotations (\`'a\`)",
              def: "Syntax used to tell the compiler the relationship between the lifetimes of different references. They don't change how long any values live; they just describe the relationships.",
            },
            {
              term: "Lifetime Elision Rules",
              def: "A set of rules the compiler uses to infer lifetimes automatically in common patterns, so you don't have to write them all the time.",
            },
            {
              term: "\`'static\` Lifetime",
              def: "A special lifetime that means the reference can live for the entire duration of the program (e.g., a string literal).",
            },
          ],
          when: [
            {
              scenario: "Returning a Reference from a Function",
              action:
                "If a function takes references as input and returns a reference, you often need to use lifetime annotations to show that the returned reference is tied to the lifetime of one of the inputs.",
            },
            {
              scenario: "Structs that Hold References",
              action:
                "If a struct field is a reference, the struct definition needs a lifetime annotation to ensure the struct instance doesn't outlive the data it refers to.",
            },
          ],
          how: [
            {
              title: "Function with Lifetimes",
              code: `// 'a is a generic lifetime parameter.
// This signature says that for some lifetime 'a, the function gets two
// string slices that both live at least as long as 'a, and it returns
// a string slice that also lives at least as long as 'a.
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let s1 = "long string";
    let s2 = "short";
    println!("Longest is {}", longest(s1, s2));
}`,
            },
            {
              title: "Struct with a Lifetime",
              code: `// This struct cannot outlive the reference it holds in \`part\`.
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    println!("Part: {}", i.part);
}`,
            },
          ],
          deeperDive: {
            title: "Fighting the Borrow Checker is Learning",
            content:
              "Encountering lifetime errors is a rite of passage for new Rust developers. While it can be frustrating, each error is the borrow checker teaching you about a potential memory safety bug that it just prevented. Understanding lifetimes means understanding how Rust provides its powerful safety guarantees without a garbage collector. It shifts bug-finding from runtime debugging to compile-time analysis.",
          },
        },
        {
          day: 14,
          title: "Smart Pointers - Beyond Basic References",
          why: "While basic references are powerful for borrowing data, certain programming scenarios demand more sophisticated ownership patterns. These include situations where data needs to have multiple owners, where recursive data structures (like linked lists or trees) necessitate heap allocation, or where runtime checks for mutability within an otherwise immutable context are required. Smart pointers in Rust provide these advanced capabilities while rigorously adhering to the language's fundamental memory safety principles.",
          what: [
            {
              term: "Smart Pointers",
              def: "These are data structures that behave like pointers but possess additional metadata and capabilities. Unlike ordinary references, which merely borrow data, smart pointers often *own* the data they point to, managing its allocation and deallocation.",
            },
            {
              term: "\`Deref\` Trait",
              def: "This trait enables a smart pointer type to behave like a regular reference. By implementing \`Deref\`, instances of the smart pointer can be dereferenced using the \`*\` operator, and they also benefit from *deref coercions*, allowing them to be automatically converted to references to their inner type when needed.",
            },
            {
              term: "\`Drop\` Trait",
              def: "The \`Drop\` trait allows for customization of the code that executes when a value goes out of scope. Smart pointers implement \`Drop\` to automatically clean up the resources they own (e.g., freeing heap memory) when they are no longer in use, preventing memory leaks.",
            },
            {
              term: "\`Box<T>\`",
              def: "The simplest smart pointer, primarily used for allocating values on the heap. \`Box<T>\` provides single ownership of the heap-allocated data. It is ideal for scenarios involving large data that might overflow the stack, recursive data structures where the size is unknown at compile time (e.g., nodes in a linked list), or for type abstraction through trait objects (\`Box<dyn Trait>\`) where the concrete type's size is not known at compile time.",
            },
            {
              term: "\`Rc<T>\` (Reference Counted)",
              def: "\`Rc<T>\` is a smart pointer that enables **multiple ownership** of data within a **single-threaded** context. It maintains a count of active references to the data, and the data is only deallocated when the last \`Rc<T>\` instance goes out of scope and its reference count drops to zero. \`Rc<T>\` is explicitly *not* thread-safe, meaning it cannot be safely shared or transferred between threads.",
            },
            {
              term: "\`Arc<T>\` (Atomically Reference Counted)",
              def: "\`Arc<T>\` is the thread-safe counterpart to \`Rc<T>\`. It also enables **multiple ownership**, but it does so safely across **multiple threads** by using atomic operations for managing its reference count. While \`Arc<T>\` provides thread safety, it incurs a slight performance overhead compared to \`Rc<T>\` due to the atomic nature of its operations.",
            },
            {
              term: "\`RefCell<T>\` (Reference Cell)",
              def: "\`RefCell<T>\` is a smart pointer that enables *interior mutability*, allowing the mutation of data even when there are immutable references to that data. Crucially, \`RefCell<T>\` enforces Rust's borrowing rules at *runtime* (leading to a panic if rules are violated) rather than at compile time. It is designed for **single-threaded** contexts and is often combined with \`Rc<T>\` (as \`Rc<RefCell<T>>\`) to allow shared, mutable data in single-threaded scenarios where multiple owners are needed. \`RefCell<T>\` is not thread-safe.",
            },
            {
              term: "Reference Cycles and \`Weak<T>\`",
              def: 'When \`Rc<T>\` or \`Arc<T>\` are used to create data structures where items refer to each other in a cycle (e.g., a parent-child relationship where children point back to parents), these cycles can lead to *memory leaks*. This occurs because the strong reference counts never drop to zero, preventing the data from being deallocated. \`Weak<T>\` is a special "weak" reference type that does not contribute to the strong reference count, making it a crucial tool for breaking these cycles and enabling proper memory deallocation. \`Weak::upgrade()\` can be used to safely obtain an \`Option<Rc<T>>\` (or \`Option<Arc<T>>\`) if the value still exists.',
            },
          ],
          when: [
            {
              scenario: "\`Box<T>\`",
              action:
                "Use \`Box<T>\` when: You have large data that needs to be stored on the heap to avoid stack overflow. You are defining recursive data structures (like linked lists or trees) where the size of the type cannot be known at compile time. You need to work with trait objects (\`Box<dyn Trait>\`) for dynamic dispatch.",
            },
            {
              scenario: "\`Rc<T>\`",
              action:
                "Employ \`Rc<T>\` when: Multiple parts of your program (within a single thread) need to own the same piece of data. You are building graph-like structures where multiple nodes might share ownership of a common child node.",
            },
            {
              scenario: "\`Arc<T>\`",
              action:
                "Choose \`Arc<T>\` when: You need to share ownership of data across multiple threads safely. It is the thread-safe equivalent of \`Rc<T>\`.",
            },
            {
              scenario: "\`RefCell<T>\`",
              action:
                "Utilize \`RefCell<T>\` when: You need to mutate data that is otherwise immutably borrowed (e.g., when implementing mock objects for testing, or when a data structure needs to update its internal state while appearing immutable externally). This is applicable only in single-threaded contexts.",
            },
            {
              scenario: "\`Weak<T>\`",
              action:
                "Implement \`Weak<T>\` to: Prevent memory leaks in data structures that might form reference cycles (e.g., doubly-linked lists or tree structures with parent pointers).",
            },
          ],
          how: [
            {
              title: "Using `Box<T>` for a List",
              code: `#[derive(Debug)]
enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn main() {
    let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(Nil))))));
    println!("{:?}", list);
}`,
            },
            {
              title: "Using `Rc<T>` for Shared Ownership",
              code: `use std::rc::Rc;
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

fn main() {
    let a = Rc::new(List::Cons(5, Rc::new(List::Cons(10, Rc::new(List::Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    
    // Rc::clone only increments the reference count, it doesn't do a deep copy.
    let b = List::Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    
    { // New inner scope
        // Create list \`c\` that also shares the tail of \`a\`
        let c = List::Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    } // \`c\` goes out of scope here, reference count for \`a\` decreases
    
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}`,
            },
            {
              title: "Using `RefCell<T>` for Interior Mutability",
              code: `use std::cell::RefCell;

fn main() {
    let x = RefCell::new(5); // \`x\` is immutable, but its interior can be mutated
    
    let borrowed_x = x.borrow(); // Get an immutable reference to the interior value
    println!("Value: {}", *borrowed_x);
    
    // The following line would panic at runtime because a mutable borrow is attempted
    // while an immutable borrow (\`borrowed_x\`) is still active.
    // let mut_borrowed_x = x.borrow_mut(); // This would panic!
    
    drop(borrowed_x); // Explicitly end the immutable borrow
    
    let mut_borrowed_x = x.borrow_mut(); // Now a mutable borrow is allowed
    *mut_borrowed_x += 1; // Mutate the interior value
    println!("New value: {}", *mut_borrowed_x);
}`,
            },
          ],
          deeperDive: {
            title: "Choosing Your Pointer",
            content:
              "Rust provides a toolbox of smart pointers, each for a specific scenario. This gives developers fine-grained control over performance and memory management. \`Box<T>\` has single ownership. \`Rc<T>\` has multiple owners but isn't thread-safe. \`Arc<T>\` has multiple owners and is thread-safe, but has a small performance cost for its atomic operations. \`RefCell<T>\` trades compile-time checks for runtime checks to allow interior mutability. Choosing the right one is a key part of writing idiomatic, efficient Rust.",
          },
        },
        {
          day: 15,
          title: "Concurrency, Testing, and Best Practices",
          why: "This final day synthesizes critical aspects of modern software development in Rust: concurrency for leveraging multi-core processors, robust testing for ensuring correctness and reliability, and adherence to best practices for building maintainable, scalable, and idiomatic projects. Understanding these elements is crucial for transitioning from writing basic programs to developing production-ready, high-performance applications. Rust's unique memory safety guarantees extend to concurrency, allowing for 'fearless concurrency,' while its built-in testing framework and community-driven best practices streamline development and collaboration.",
          what: [
            {
              term: "Concurrency",
              def: "The ability to execute multiple parts of a program independently or simultaneously. Rust's approach to concurrency is designed to be safe and efficient, leveraging its ownership and type systems to prevent common concurrency bugs (like data races) at compile time.",
            },
            {
              term: "Threads",
              def: "Rust's standard library provides mechanisms for creating and managing threads using \`std::thread::spawn\`. Threads allow different parts of code to run concurrently.",
            },
            {
              term: "Message Passing (Channels)",
              def: 'A common concurrency pattern where threads communicate by sending data to each other through channels (multiple producer, single consumer - \`mpsc\`). This approach adheres to the principle "Do not communicate by sharing memory; instead, share memory by communicating." Ownership of data is transferred when sent through a channel, ensuring safety.',
            },
            {
              term: "Shared-State Concurrency (Mutexes)",
              def: "When multiple threads need to access and modify the same shared data, mutexes (\`std::sync::Mutex\`) are used. A mutex ensures that only one thread can access the guarded data at a time by requiring a lock to be acquired. Rust's \`MutexGuard\` automatically releases the lock when it goes out of scope, preventing common locking bugs.",
            },
            {
              term: "\`Send\` and \`Sync\` Traits",
              def: "These are marker traits that extend Rust's concurrency guarantees to user-defined types. \`Send\` indicates that ownership of a type can be safely transferred between threads. Most Rust types are \`Send\`, with \`Rc<T>\` being a notable exception (not \`Send\`). \`Sync\` indicates that it is safe for a type to be referenced from multiple threads. A type \`T\` is \`Sync\` if \`&T\` (an immutable reference to \`T\`) is \`Send\`. \`RefCell<T>\` is not \`Sync\`, but \`Mutex<T>\` is.",
            },
            {
              term: "\`Arc<T>\` for Shared Mutable State",
              def: "\`Arc<T>\` is crucial for sharing ownership of data across multiple threads. When combined with \`Mutex<T>\` (e.g., \`Arc<Mutex<T>>\`), it allows safe, shared, mutable state across threads.",
            },
            {
              term: "Testing",
              def: "Rust provides built-in support for writing automated tests to ensure code correctness and prevent regressions.",
            },
            {
              term: "Unit Tests",
              def: "Small, focused tests that verify individual units of code (e.g., functions, modules) in isolation. They are typically placed in an inner \`tests\` module within the same file as the code being tested, annotated with \`#[cfg(test)]\`.",
            },
            {
              term: "Integration Tests",
              def: "Tests that are external to the library and use its public API to ensure that different parts of the library work together correctly. They reside in a separate \`tests/\` directory at the project root.",
            },
            {
              term: "Doc Tests",
              def: "Code examples embedded directly within documentation comments (\`///\`) that are compiled and run as part of the test suite. This ensures that documentation remains accurate and up-to-date with the code.",
            },
            {
              term: "Testing Macros",
              def: "\`assert!\`, \`assert_eq!\`, \`assert_ne!\` for asserting conditions and equality/inequality. \`#[should_panic]\` for testing functions that are expected to panic.",
            },
            {
              term: "\`cargo test\`",
              def: "The command used to run all tests (unit, integration, doc tests) in a project.",
            },
            {
              term: "Best Practices",
              def: "Adhering to conventions and best practices is crucial for long-term project health and collaboration.",
            },
            {
              term: "Cargo Conventions",
              def: "\`src/main.rs\` for binary crate root, \`src/lib.rs\` for library crate root. \`src/bin/\` for multiple binaries. \`tests/\` for integration tests.",
            },
            {
              term: "\`Cargo.toml\` Configuration",
              def: "Managing package metadata (name, version, description, license), dependencies, features, and build profiles.",
            },
            {
              term: "Workspaces",
              def: "For larger projects composed of multiple interdependent crates, a Cargo workspace allows them to be managed together, sharing a common \`Cargo.lock\` and \`target\` directory.",
            },
            {
              term: "Idiomatic Rust",
              def: "Writing code that aligns with the community's established patterns and principles, often guided by the Rust API Guidelines and tools like Clippy. This includes favoring composition over inheritance, explicit state management, and expressive data types.",
            },
            {
              term: "Documentation",
              def: "Writing clear, comprehensive documentation comments (\`///\` and \`//!\`) for public APIs, which can also include runnable code examples.",
            },
          ],
          when: [
            {
              scenario: "Concurrency",
              action:
                "When a program needs to perform multiple tasks simultaneously to improve performance, responsiveness, or handle parallel workloads, especially on multi-core systems.",
            },
            {
              scenario: "Testing",
              action:
                "Continuously throughout development to ensure new features work as expected and prevent regressions. Write unit tests for fine-grained component verification, integration tests for end-to-end flow, and doc tests to keep examples correct.",
            },
            {
              scenario: "Best Practices",
              action:
                "Apply from the very beginning of a project and maintain consistently. Follow Cargo conventions for structure, use linters like Clippy, format with Rustfmt, and prioritize clear documentation for any public API.",
            },
          ],
          how: [
            {
              title: "Spawning a Thread",
              code: `use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    // Wait for the spawned thread to finish.
    handle.join().unwrap();
}`,
            },
            {
              title: "Writing a Simple Test",
              code: `// This would go in a library file like src/lib.rs
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*; // Import the functions from the outer module

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
// Run with \`cargo test\`
`,
            },
          ],
          deeperDive: {
            title: "Fearless Development",
            content:
              "The term \"fearless concurrency\" isn't just marketing. Because Rust's ownership and type systems prevent data races at compile time, you can refactor concurrent code or introduce parallelism with a much higher degree of confidence than in many other languages. The comprehensive testing framework complements this by helping you verify the *logic* of your code, while the compiler verifies memory and thread safety. This combination allows developers to build fast, concurrent, and correct software more easily.",
          },
        },
      ];

      let state = {
        currentDayIndex: 0,
        completedDays: new Set(),
      };

      function saveState() {
        const stateToSave = {
          currentDayIndex: state.currentDayIndex,
          completedDays: Array.from(state.completedDays),
        };
        localStorage.setItem("rustGuideProgress", JSON.stringify(stateToSave));
      }

      document.addEventListener("DOMContentLoaded", () => {
        const dayList = document.getElementById("day-list");
        const dayTitle = document.getElementById("day-title");
        const dayTopic = document.getElementById("day-topic");
        const tabsContainer = document.getElementById("tabs");
        const tabContentContainer = document.getElementById("tab-content");
        const deeperDiveContainer = document.getElementById(
          "deeper-dive-container"
        );
        const progressBar = document.getElementById("progress-bar");
        const progressText = document.getElementById("progress-text");
        const sidebar = document.getElementById("sidebar");
        const sidebarToggle = document.getElementById("sidebar-toggle");
        const copiedToast = document.getElementById("copied-toast");

        // Load state from localStorage
        const savedStateJSON = localStorage.getItem("rustGuideProgress");
        if (savedStateJSON) {
          const savedState = JSON.parse(savedStateJSON);
          state.currentDayIndex = savedState.currentDayIndex || 0;
          state.completedDays = new Set(savedState.completedDays || []);
        }

        function showToast(message) {
          copiedToast.textContent = message;
          copiedToast.classList.remove("opacity-0");
          setTimeout(() => {
            copiedToast.classList.add("opacity-0");
          }, 2000);
        }

        function updateProgress() {
          const completedCount = state.completedDays.size;
          const totalDays = rustGuideData.length;
          const percentage =
            totalDays > 0 ? (completedCount / totalDays) * 100 : 0;

          progressBar.style.width = `${percentage}%`;
          progressText.textContent = `Progress: ${Math.round(percentage)}%`;
        }

        function renderSidebar() {
          dayList.innerHTML = "";
          rustGuideData.forEach((day, index) => {
            const li = document.createElement("li");
            const isCompleted = state.completedDays.has(day.day);
            const isActive = state.currentDayIndex === index;

            li.innerHTML = `
                <a href="#" data-day-index="${index}" class="day-link flex items-center justify-between p-2.5 rounded-md transition-colors ${
              isActive
                ? "bg-teal-100 text-teal-800 font-semibold"
                : "hover:bg-slate-100 text-slate-600"
            }">
                    <div class="flex items-center">
                        <input type="checkbox" data-day-id="${
                          day.day
                        }" class="progress-checkbox h-4 w-4 rounded border-slate-300 text-teal-600 focus:ring-teal-500 mr-3" ${
              isCompleted ? "checked" : ""
            }>
                        <span class="flex-grow">Day ${day.day}: ${
              day.title
            }</span>
                    </div>
                </a>
            `;
            dayList.appendChild(li);
          });
          updateProgress();
        }

        function renderContent(dayIndex) {
          state.currentDayIndex = dayIndex;
          saveState(); // Save state whenever the current day changes
          const dayData = rustGuideData[dayIndex];

          dayTitle.textContent = `Day ${dayData.day}`;
          dayTopic.textContent = dayData.title;

          // Render Tabs
          const tabs = ["Why", "What", "When", "How"];
          tabsContainer.innerHTML = tabs
            .map(
              (tab, index) => `
            <button data-tab="${tab.toLowerCase()}" class="tab-link whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm ${
                index === 0
                  ? "border-teal-500 text-teal-600"
                  : "border-transparent text-slate-500 hover:text-slate-700 hover:border-slate-300"
              }">
                ${tab}
            </button>
        `
            )
            .join("");

          renderTabContent(dayData, "why");

          // Render Deeper Dive
          deeperDiveContainer.innerHTML = `
            <div class="bg-amber-50 border-l-4 border-amber-400 p-4 rounded-r-lg">
                <h3 class="text-lg font-semibold text-amber-900 mb-2">${dayData.deeperDive.title}</h3>
                <p class="text-amber-800">${dayData.deeperDive.content}</p>
            </div>
        `;

          renderSidebar();
          if (window.innerWidth < 768) {
            sidebar.classList.remove("open");
          }
        }

        function renderTabContent(dayData, activeTab) {
          let content = "";
          switch (activeTab) {
            case "why":
              content = `<p class="prose">${dayData.why}</p>`;
              break;
            case "what":
              content = `<ul class="space-y-4">${dayData.what
                .map(
                  (item) =>
                    `<li><strong class="font-semibold text-slate-900">${item.term}:</strong> <span class="text-slate-700">${item.def}</span></li>`
                )
                .join("")}</ul>`;
              break;
            case "when":
              content = `<ul class="space-y-4">${dayData.when
                .map(
                  (item) =>
                    `<li><strong class="font-semibold text-slate-900">${item.scenario}:</strong> <span class="text-slate-700">${item.action}</span></li>`
                )
                .join("")}</ul>`;
              break;
            case "how":
              content = `<div class="space-y-6">${dayData.how
                .map(
                  (example, index) => `
                    <div>
                        <h4 class="font-semibold mb-2 text-slate-800">${
                          example.title
                        }</h4>
                        <div class="code-block">
                            <pre class="bg-slate-800 text-slate-100 rounded-lg p-4 overflow-x-auto"><code class="language-rust">${example.code
                              .trim()
                              .replace(/&/g, "&amp;") // Must be first
                              .replace(/</g, "&lt;")
                              .replace(/>/g, "&gt;")
                              .replace(/"/g, "&quot;")
                              .replace(/'/g, "&#039;")}</code></pre>
                            <button class="copy-button" data-code-index="${index}">Copy</button>
                        </div>
                    </div>
                `
                )
                .join("")}</div>`;
              break;
          }
          tabContentContainer.innerHTML = content;
        }

        // Event Listeners
        dayList.addEventListener("click", (e) => {
          if (e.target.closest(".day-link")) {
            e.preventDefault();
            const dayIndex = parseInt(
              e.target.closest(".day-link").dataset.dayIndex,
              10
            );
            renderContent(dayIndex);
          }

          if (e.target.classList.contains("progress-checkbox")) {
            const dayId = parseInt(e.target.dataset.dayId, 10);
            if (e.target.checked) {
              state.completedDays.add(dayId);
            } else {
              state.completedDays.delete(dayId);
            }
            saveState(); // Save progress
            updateProgress();
            // Re-render sidebar to update styles if needed, though not strictly necessary
            const currentActiveLink = dayList.querySelector(
              `a[data-day-index="${state.currentDayIndex}"]`
            );
            if (currentActiveLink) {
              currentActiveLink.classList.add(
                "bg-teal-100",
                "text-teal-800",
                "font-semibold"
              );
            }
          }
        });

        tabsContainer.addEventListener("click", (e) => {
          if (e.target.classList.contains("tab-link")) {
            const activeTab = e.target.dataset.tab;
            tabsContainer.querySelectorAll(".tab-link").forEach((tab) => {
              tab.classList.remove("border-teal-500", "text-teal-600");
              tab.classList.add("border-transparent", "text-slate-500");
            });
            e.target.classList.add("border-teal-500", "text-teal-600");
            e.target.classList.remove("border-transparent", "text-slate-500");

            renderTabContent(rustGuideData[state.currentDayIndex], activeTab);
          }
        });

        tabContentContainer.addEventListener("click", (e) => {
          if (e.target.classList.contains("copy-button")) {
            const codeIndex = parseInt(e.target.dataset.codeIndex, 10);
            const codeToCopy =
              rustGuideData[state.currentDayIndex].how[codeIndex].code;

            const textarea = document.createElement("textarea");
            textarea.value = codeToCopy;
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand("copy");
              showToast("Copied to clipboard!");
            } catch (err) {
              showToast("Failed to copy!");
            }
            document.body.removeChild(textarea);
          }
        });

        sidebarToggle.addEventListener("click", () => {
          sidebar.classList.toggle("open");
        });

        // Close sidebar if clicking outside of it on mobile
        document.addEventListener("click", (e) => {
          if (
            !sidebar.contains(e.target) &&
            !sidebarToggle.contains(e.target) &&
            sidebar.classList.contains("open")
          ) {
            sidebar.classList.remove("open");
          }
        });

        // Initial render
        renderContent(state.currentDayIndex);
      });
    </script>
  </body>
</html>
